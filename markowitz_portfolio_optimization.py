# -*- coding: utf-8 -*-
"""Markowitz portfolio optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_NUtUpWuf95iJnLdmnsn4NqRsfPtlY0_
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import quandl
import scipy.optimize as sco
plt.style.use('fivethirtyeight')
np.random.seed(777)
# %matplotlib inline
# %config InlineBackend.figure_format = 'retina'

!pip install yfinance

import yfinance as yf

# Create a Portfolio
symbols = [
    'AAPL',
    'MSFT',
    'META',
    'AMZN',
    'XOM',
    'JNJ',
    'DIS',
    'T',
    'UPS',
    'HSY'
]

# Get the stock data
data = yf.download(symbols, start="2023-11-01", end="2024-01-31")
data.head()

# Extract only the specified columns
selected_columns = [
    ('Adj Close', 'AAPL'),
    ('Adj Close', 'AMZN'),
    ('Adj Close', 'DIS'),
    ('Adj Close', 'HSY'),
    ('Adj Close', 'JNJ'),
    ('Adj Close', 'META'),
    ('Adj Close', 'MSFT'),
    ('Adj Close', 'T'),
    ('Adj Close', 'UPS'),
    ('Adj Close', 'XOM')
]
selected_data = data[selected_columns]
selected_data.head()

# Save selected data to CSV
selected_data.to_csv('selected_data.csv')

# Verify the file is saved
import os
os.listdir()  # Lists files in the current directory, you should see 'selected_data.csv'

selected_data.info()

import plotly.graph_objects as go

fig = go.Figure()

for c in selected_data.columns.values:
    column_name = str(c)  # Convert tuple to string
    fig.add_trace(go.Scatter(x=selected_data.index, y=selected_data[c], mode='lines', name=column_name))

fig.update_layout(
    title='Stock Prices',
    xaxis_title='Date',
    yaxis_title='Price in $',
    legend=dict(x=1, y=1, traceorder='normal', font=dict(family='sans-serif', size=12)),
    margin=dict(l=30, r=20, t=40, b=20)
)

fig.show()

returns = selected_data.pct_change()

fig = go.Figure()

for c in returns.columns.values:
    fig.add_trace(go.Scatter(x=returns.index, y=returns[c], mode='lines', name=str(c)))

fig.update_layout(
    title='Daily Returns',
    xaxis_title='Date',
    yaxis_title='Daily Returns',
    legend=dict(x=1, y=1, traceorder='normal', font=dict(family='sans-serif', size=12)),
    margin=dict(l=30, r=20, t=40, b=20)
)

fig.show()

def portfolio_annualised_performance(weights, mean_returns, cov_matrix):
    returns = np.sum(mean_returns*weights ) * 63
    std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) * np.sqrt(63)
    return std, returns

def random_portfolios(num_portfolios, mean_returns, cov_matrix, risk_free_rate):
    results = np.zeros((3,num_portfolios))
    weights_record = []
    for i in range(num_portfolios):
        weights = np.random.random(10)
        weights /= np.sum(weights)
        weights_record.append(weights)
        portfolio_std_dev, portfolio_return = portfolio_annualised_performance(weights, mean_returns, cov_matrix)
        results[0,i] = portfolio_std_dev
        results[1,i] = portfolio_return
        results[2,i] = (portfolio_return - risk_free_rate) / portfolio_std_dev
    return results, weights_record

returns = selected_data.pct_change()
mean_returns = returns.mean()
cov_matrix = returns.cov()
num_portfolios = 50000
risk_free_rate = 0.043

print(mean_returns)

cov_matrix

diagonal_elements = np.diag(cov_matrix)
diagonal_elements

def display_simulated_ef_with_random(mean_returns, cov_matrix, num_portfolios, risk_free_rate):
    results, weights = random_portfolios(num_portfolios,mean_returns, cov_matrix, risk_free_rate)

    max_sharpe_idx = np.argmax(results[2])
    sdp, rp = results[0,max_sharpe_idx], results[1,max_sharpe_idx]
    max_sharpe_allocation = pd.DataFrame(weights[max_sharpe_idx],index=selected_data.columns,columns=['allocation'])
    max_sharpe_allocation.allocation = [round(i*100,2)for i in max_sharpe_allocation.allocation]
    max_sharpe_allocation = max_sharpe_allocation.T

    min_vol_idx = np.argmin(results[0])
    sdp_min, rp_min = results[0,min_vol_idx], results[1,min_vol_idx]
    min_vol_allocation = pd.DataFrame(weights[min_vol_idx],index=selected_data.columns,columns=['allocation'])
    min_vol_allocation.allocation = [round(i*100,2)for i in min_vol_allocation.allocation]
    min_vol_allocation = min_vol_allocation.T

    print("-"*80)
    print("Maximum Sharpe Ratio Portfolio Allocation\n")
    print("Annualised Return:", round(rp, 2))
    print("Annualised Volatility:", round(sdp, 2))
    print("\n")
    print(max_sharpe_allocation)
    print("-"*80)
    print("Minimum Volatility Portfolio Allocation\n")
    print("Annualised Return:", round(rp_min, 2))
    print("Annualised Volatility:", round(sdp_min, 2))
    print("\n")
    print(min_vol_allocation)


    plt.figure(figsize=(10, 7))
    plt.scatter(results[0,:],results[1,:],c=results[2,:],cmap='YlGnBu', marker='o', s=10, alpha=0.3)
    plt.colorbar()
    plt.scatter(sdp,rp,marker='*',color='r',s=500, label='Maximum Sharpe ratio')
    plt.scatter(sdp_min,rp_min,marker='*',color='g',s=500, label='Minimum volatility')
    plt.title('Simulated Portfolio Optimization based on Efficient Frontier')
    plt.xlabel('annualised volatility')
    plt.ylabel('annualised returns')
    plt.legend(labelspacing=0.8)

import plotly.graph_objects as go
import numpy as np
import pandas as pd

def display_simulated_ef_with_random(mean_returns, cov_matrix, num_portfolios, risk_free_rate):
    results, weights = random_portfolios(num_portfolios, mean_returns, cov_matrix, risk_free_rate)

    max_sharpe_idx = np.argmax(results[2])
    sdp, rp = results[0, max_sharpe_idx], results[1, max_sharpe_idx]
    max_sharpe_allocation = pd.DataFrame(weights[max_sharpe_idx], index=selected_data.columns, columns=['allocation'])
    max_sharpe_allocation.allocation = [round(i*100, 2) for i in max_sharpe_allocation.allocation]
    max_sharpe_allocation = max_sharpe_allocation.T

    min_vol_idx = np.argmin(results[0])
    sdp_min, rp_min = results[0, min_vol_idx], results[1, min_vol_idx]
    min_vol_allocation = pd.DataFrame(weights[min_vol_idx], index=selected_data.columns, columns=['allocation'])
    min_vol_allocation.allocation = [round(i*100, 2) for i in min_vol_allocation.allocation]
    min_vol_allocation = min_vol_allocation.T

    print("-"*80)
    print("Maximum Sharpe Ratio Portfolio Allocation\n")
    print("Annualised Return:", round(rp, 2))
    print("Annualised Volatility:", round(sdp, 2))
    print("\n")
    print(max_sharpe_allocation)
    print("-"*80)
    print("Minimum Volatility Portfolio Allocation\n")
    print("Annualised Return:", round(rp_min, 2))
    print("Annualised Volatility:", round(sdp_min, 2))
    print("\n")
    print(min_vol_allocation)

    # Scatter plot
    fig = go.Figure()

    fig.add_trace(go.Scatter(
        x=results[0,:],
        y=results[1,:],
        mode='markers',
        marker=dict(
            color=results[2,:],
            colorscale='YlGnBu',
            size=10,
            opacity=0.3,
        ),
        showlegend=False
    ))

    fig.add_trace(go.Scatter(
        x=[sdp],
        y=[rp],
        mode='markers',
        marker=dict(
            color='red',
            symbol='star',
            size=14,
        ),
        name='Maximum Sharpe Ratio',
    ))

    fig.add_trace(go.Scatter(
        x=[sdp_min],
        y=[rp_min],
        mode='markers',
        marker=dict(
            color='green',
            symbol='star',
            size=14,
        ),
        name='Minimum Volatility',
    ))

    fig.update_layout(
        title='Simulated Portfolio Optimization based on Efficient Frontier',
        xaxis_title='Annualised Volatility',
        yaxis_title='Annualised Returns',
        legend=dict(
            x=0.02,
            y=0.98,
            bgcolor='rgba(255, 255, 255, 0.5)',
            bordercolor='rgba(255, 255, 255, 0.5)',
            font=dict(size=10),
        ),
        margin=dict(l=30, r=10, t=40, b=10),
    )

    fig.show()

display_simulated_ef_with_random(mean_returns, cov_matrix, num_portfolios, risk_free_rate)